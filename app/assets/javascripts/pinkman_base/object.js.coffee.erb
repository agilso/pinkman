class window.PinkmanObject

  @pinkmanType: "object"
  @privateAttributes: ['isPink','isObject','pinkey','config']

  constructor: ->
    @isPink = true
    @isObject = true
    @pinkey = Pinkman.all.length + 1
    Pinkman.objects.push(this)
    Pinkman.all.push(this)


  apiUrl: () ->
    @config.apiUrl

  # Desc: assign attributes from a pure javascript object
  # Usage: a.assign( {attribute: value} )
  assign: (obj) ->
    if typeof obj == "object"
      for k,v of obj
        if typeof v == 'object' and this[k]? and this[k].isPink? and not v.isPink
          this[k].assign(v)
        else
          this.set(k,v) 
      return true
    else
      return false

  # Desc: returns a javascript object version of this
  # Usage: a.attributes() #-> {key: value, key: value, ...}
  attributes: () ->
    a = new Object
    for k,v of this
      if PinkmanObject.privateAttributes.indexOf(k) == -1 and typeof v != 'function'
        if v.isPink and v.isObject
          a[k] = v.attributes()
        else
          a[k] = v
    return a

  set: (attr,value, callback = "" ) ->
    if attr? and value?
      this[attr] = value
      callback(this) if typeof callback == "function"
      return true
    else 
      return false

  # attributesKeys: () ->
  #   array = Object.keys(@attributes()) 
  #   if array.length > 0
  #     for attr in ['pinkey','objectId','config','pinkey','helper']
  #       array.splice array.indexOf(attr), 1
  #   array
 

  className: ->
    @constructor.name

  # @view = new Object

  
  # pushToRenderQueue: (options) ->
  #   @renderQueue = [] unless @renderQueue?
  #   options.reRendering = no

  #   # check if this exactly options is already in the renderQueue
  #   alreadyPresent = false
  #   for obj in @renderQueue
  #     value = true
  #     for k,v of obj
  #       if typeof(obj[k]) == 'function' and typeof(options[k]) == 'function'
  #         value = false if obj[k].toString().replace(/\s/g, '') != options[k].toString().replace(/\s/g, '')
  #       else if obj[k] != options[k]
  #         value = false 
  #       else
  #     alreadyPresent = true if value

  #   # insert options to renderQueue if it isn't already there
  #   @renderQueue.push options unless alreadyPresent

  # clearRenderQueue: () ->
  #   @renderQueue = []



  # clearCollections: ->
  #   if @collectionsIds? and @collectionsIds.length >= 1
  #     for col in @collections()
  #       col.remove this
  #     @collectionsIds = []

  # toString: () ->
  #   array = []
  #   for a in @attributesKeys()
  #     array.push "#{a}: #{this[a]};"
  #   array.join("\n")

  

  # addCollection: (id) ->
  #   if id?
  #     @collectionsIds = [] unless @collectionsIds?
  #     @collectionsIds.push(id)
  #     return true
  #   else
  #     return false

  # removeCollection: (id) ->
  #   if id? and @collectionsIds?
  #     @collectionsIds.splice @collectionsIds.indexOf(id), 1
  #     return true
  #   else
  #     return false    

  # collections: () ->
  #   if @collectionsIds? and @collectionsIds.length >= 1
  #     c = []
  #     for id in @collectionsIds
  #       c.push(PinkmanGlue.collections[id])
  #     return c
  #   else
  #     return false


  # render: (options) ->
  #   defaultOptions =
  #     template: null
  #     target: null
  #     reRender: yes
  #     reRendering: no
  #     callback: ""
  #     history: null

  #   # setting options object
  #   if typeof options == "object" 
  #     for k,v of defaultOptions
  #       options[k] = defaultOptions[k] unless options[k]?
  #   else
  #     options = defaultOptions

  #   if options.template? and options.target?

  #     # Compiling template
  #     content = Pinkman.render template: options.template, object: this      

  #     # history
  #     if window? and history? and options.history? and !options.reRendering
  #       options.reRendering = no
  
  #       history.pushState({ pinkey: @pinkey }, "", (Pinkman.pathname + options.history)) 
  #       Pinkman.popstate()
      
  #     # saves rendering information to rerender later      
  #     @pushToRenderQueue(options) if options.reRender

  #     # rendering
  #     $("#" + options.target).html(content)

  #     # checks and sync select options with the pinkman object
  #     $("##{options.target} select").each (i,el) ->
  #       obj = Pinkman.get($(el).data('pinkey'))
  #       $(el).find("option[value='#{obj[$(el).attr('name')]}']").attr('selected','selected')

  #     options.callback(this) if typeof options.callback == "function"
  #   true

  # reRender: (options) ->
  #   defaultOptions =
  #     collection: yes
  #     callback: ""

  #   # setting options object
  #   if typeof options == "object" 
  #     for k,v of defaultOptions
  #       options[k] = defaultOptions[k] unless options[k]?
  #   else
  #     options = defaultOptions

  #   if @renderQueue? and @renderQueue instanceof Array and @renderQueue.length >= 1
  #     for config in @renderQueue
  #       config.reRendering = yes
  #       @render(config)
  #   if options.collection
  #     if @collectionsIds? and @collectionsIds.length >= 1
  #       for c in @collections()
  #         c.reRender()
  #   options.callback(this) if typeof options.callback == "function"
  

  # prev: (collectionID=0) =>
  #   @collections()[collectionID].prev(this) if @collections()[collectionID]?
  #   # @collections()[collectionID].prev(this) if @collections()?

  # next: (collectionID=0) =>
  #   @collections()[collectionID].next(this) if @collections()[collectionID]?

  # pinkfy: (attribute,pinkmanClass,callback = "") ->
  #   if pinkmanClass.pinkmanType == "collection" and (this[attribute] instanceof Array)
  #     collection = new pinkmanClass
  #     for obj in this[attribute]
  #       pinkmanObject = collection.config.memberClass()
  #       pinkmanObject.assign(obj)
  #       collection.push(pinkmanObject)
  #     this[attribute] = collection
  #     callback(collection) if typeof callback == "function"
  #     return this
  #   else if pinkmanClass.pinkmanType == "object" and (typeof this[attribute] == "object")
  #     pinkmanObject = new pinkmanClass
  #     if (this[attribute] instanceof Array) and (this[attribute].length)
  #       pinkmanObject.assign(this[attribute][0]) 
  #     else
  #       pinkmanObject.assign this[attribute]
      
  #     this[attribute] = pinkmanObject
  #     callback(pinkmanObject) if typeof callback == "function"
  #     return this
  #   else
  #     return false

  # firstError: ->
  #   if @errors?
  #     attr = Object.keys(@errors)[0]
  #     "#{attr} #{@errors[attr][0]}"


  # # Ajax - Area

  # @find: (id, callback = "") ->
  #   obj = new this
  #   ajax = jQuery.ajax "/" + obj.apiUrl() + "/" + id.toString(),
  #     type: "GET"
  #     dataType: 'json'
  #   ajax.done (response) =>
  #     if response.errors?
  #       obj.set('errors',response.errors)
  #       return false
  #     else
  #       # window.r = response
  #       # console.log response
  #       # console.log 'resposta acima - obj abaixo'
  #       # window.o = obj
  #       # console.log obj
  #       obj.assign(response)
  #     if typeof callback == "function"
  #       callback(obj)
  #   return obj

  # @fetchFromUrl: (url,callback = "") ->
  #   obj = new this
  #   ajax = jQuery.ajax "/" + url,
  #     type: "GET"
  #     dataType: 'json'
  #   ajax.done (response) =>
  #     if response.errors?
  #       obj.set('errors',response.errors)
  #       return false
  #     else
  #       obj.assign response
  #     if typeof callback == "function"
  #       callback(obj)
  #   return obj

  # @fetchFrom: (actionUrl, id, callback = "") ->
  #   if actionUrl? and id?
  #     obj = new this
  #     ajax = jQuery.ajax "/" + obj.apiUrl() + "/" + actionUrl.toString() + "/" + id.toString(),
  #       type: "GET"
  #       dataType: 'json'
  #     ajax.done (response) =>
  #       if response.errors?
  #         obj.set('errors',response.errors)
  #         return false
  #       else
  #         obj.assign response
  #       if typeof callback == "function"
  #         callback(obj)
  #     return obj


  # create: (callback = "") ->
  #   unless @id?
  #     ajax = jQuery.ajax "/" + @apiUrl(),
  #       beforeSend: (xhr) -> 
  #         xhr.setRequestHeader('X-CSRF-Token', $('meta[name="csrf-token"]').attr('content'))
  #       dataType: 'json'
  #       type: "POST"
  #       data: { "pink_obj": @attributes() }

  #     ajax.done (response) =>
  #       if response.errors?
  #         @errors = response.errors
  #       else
  #         delete @errors
  #         @assign(response)
  #       if typeof callback == "function"
  #         callback(this)
  #   return this


  # update: (callback= "") ->
  #   if @id?
  #     ajax = jQuery.ajax("/" + @apiUrl() + "/" + @id,
  #       beforeSend: (xhr) -> 
  #         xhr.setRequestHeader('X-CSRF-Token', $('meta[name="csrf-token"]').attr('content'))
  #       dataType: 'json'
  #       type: "PATCH"
  #       data: { "pink_obj": @attributes() }
  #     )
  #     ajax.done (response) =>
  #       if response.errors?
  #         @errors = response.errors
  #       else
  #         delete @errors
  #         @assign(response)
  #       if typeof callback == "function"
  #         callback(this)
  #   return this

  # reload: (callback) ->
  #   if @id?
  #     ajax = jQuery.ajax "/" + @apiUrl() + "/" + @id,
  #       type: "GET"
  #       dataType: 'json'
  #     ajax.done (response) =>
  #       if response.errors?
  #         @errors = response.errors
  #         return false
  #       else
  #         @assign(response)
  #         if typeof callback == 'function'
  #           callback(this)
  #     return this

  # updateAttributes: (obj) ->
  #   if this.assign(obj)
  #     this.save()
  #     return this
  #   else
  #     return false

  # save: (callback = "") ->
  #   # console.log 'entrou no save'
  #   # console.log this.pinkey
  #   if @id?
  #     if typeof callback == "function"
  #       this.update (obj) ->
  #         callback(obj)
  #     else
  #       this.update()
  #   else
  #     if typeof callback == "function"
  #       this.create (obj) ->
  #         callback(obj)
  #     else
  #       this.create()

  # destroy: (callback="") ->
  #   if @id?
  #     ajax = jQuery.ajax("/" + @apiUrl() + "/" + @id,
  #       beforeSend: (xhr) -> 
  #         xhr.setRequestHeader('X-CSRF-Token', $('meta[name="csrf-token"]').attr('content'))
  #       dataType: 'json'
  #       type: "DELETE"
  #     )
  #     ajax.done (response) =>
  #       if response.errors?
  #         @errors = response.errors
  #       else
  #         @assign(response)
  #         @id = null
  #         @clearCollections()
  #       if typeof callback == "function"
  #         callback(this)
  #     return this
  #   else
  #     return false