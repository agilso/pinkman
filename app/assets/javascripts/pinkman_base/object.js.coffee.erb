class window.PinkmanObject extends window.PinkmanCommon

  @pinkmanType: 'object'

  constructor: (args...) ->
    super(args...)
    @isPink = true
    @isObject = true
    @pinkmanType = 'object'

    @collections = new PinkmanCollection
    @pinkey = Pinkman.all.length

    Pinkman.objects.push(this)
    Pinkman.all.push(this)

  # Desc: assign attributes from a pure javascript object
  # Usage: a.assign( {attribute: value} )
  assign: (obj) ->
    if typeof obj == 'object'
      for k,v of obj
        if typeof v == 'object' and this[k]? and this[k].isPink and not v.isPink
          this[k].assign(v)
        else
          this.set(k,v) 
      return true
    else
      return false

  # Desc: returns a javascript object version of this
  # Usage: a.attributes() #-> {key: value, key: value, ...}
  attributes: () ->
    a = new Object
    for k,v of this
      if PinkmanObject.privateAttributes.indexOf(k) == -1 and typeof v != 'function'
        if v.isPink
          a[k] = v.attributes()
        else
          a[k] = v
    return a

  # Desc: json version of this
  # desc: used in api comunications
  json: () ->
    a = new Object
    for k,v of this
      if PinkmanObject.privateAttributes.indexOf(k) == -1 and typeof v != 'function'
        a[k] = if v.isPink then v.json() else v
    return a
  
  # Desc: returns a array of attributes keys
  # Usage:
  # a.set('a','b'); a.set('x',value)
  # a.attributesKeys() #-> ['a','x']
  attributesKeys: ->
    Object.keys(@attributes())

  # Desc: Alias for attributesKeys
  keys: () ->
    @attributesKeys()

  toString: () ->
    array = []
    array.push("(#{@className()})")
    for a in @attributesKeys()
      array.push "#{a}: #{this[a]};"
    array.join(" ")

  # --- Collection related functions --- # 

  # Desc: return the next obj (after this) in a collection
  # Try to guess the collection if not provided
  next: (collection='') ->
    if collection.isPink and collection.pinkmanType == 'collection'
      collection.next(this)
    else if Pinkman.isNumber(collection)
      c = @collections.get(collection)
      c.next(this) if c?
    else if not collection? or collection==''
      @collections.first().next(this) if @collections.any()

  # Desc: return the previous obj (before this) in a collection
  # Try to guess the collection if not provided
  prev: (collection='') ->
    if collection.isPink and collection.pinkmanType == 'collection'
      collection.prev(this)
    else if Pinkman.isNumber(collection)
      c = @collections.get(collection)
      c.prev(this) if c?
    else if not collection? or collection==''
      @collections.first().prev(this) if @collections.any()

  # Desc: remove this object from all collections
  clearCollections: ->
    c.remove(this) for c in @collections.collection

  # alias for clearCollections
  removeFromCollections: ->
    @clearCollections()

  # alias for clearCollections
  removeFromAllCollections: ->
    @clearCollections()

  # alias for clearCollections
  removeAllCollections: ->
    @clearCollections()

  # --- Error related --- #

  # Desc: return first error message
  firstError: ->
    if @errors?
      attr = Object.keys(@errors)[0]
      "#{attr} #{@errors[attr][0]}"

  # --- Ajax --- #

  @find: (id, callback='') ->
    obj = new this
    Pinkman.ajax.get 
      url: obj.api() + id,
      complete: (response) ->
        obj.assign(response)
        if obj.error? or obj.errors? 
          throw new Error(obj.firstError())
          return false
        else
          callback(obj) if callback? and typeof callback == 'function'
    return(obj)
  
  create: (callback='') ->
    unless @id?
      Pinkman.ajax.post
        url: @api()
        data: { pink_obj: @json(), scope: this.constructor.scope }
        complete: (response) =>
          @assign(response)
          delete @errors unless response.errors?
          callback(this) if callback? and typeof callback=='function'
      return(this)

  update: (callback='') ->
    if @id?
      Pinkman.ajax.patch
        url: @api() + @id
        data: { pink_obj: @json(), scope: this.constructor.scope }
        complete: (response) =>
          @assign(response)
          delete @errors unless response.errors?
          callback(this) if callback? and typeof callback=='function'
      return(this)

  reload: (callback) ->
    Pinkman.ajax.get 
      url: @api() + @id,
      complete: (response) =>
        @assign(response)
        if @error? or @errors? 
          throw new Error(@firstError())
          return false
        else
          callback(this) if callback? and typeof callback == 'function'
    return(this)
  
  updateAttributes: (obj) ->
    if this.assign(obj)
      this.save (obj) ->
        return(obj)
    else
      return false


  save: (callback='') ->
    if @id? and @id!='' then @update(callback) else @create(callback)
        
  
  destroy: (callback='') ->
    if @id?
      @removeFromAllCollections()
      Pinkman.ajax.delete
        url: @api() + @id
        complete: (response) =>
          @assign(response)
          delete @errors unless response.errors?
          if @errors?
            throw new Error(@firstError())
            return(false)
          else
            @id = null
            callback(this) if typeof callback=='function'
      return(this)
    else
      return(false)

window.Pinkman.object = window.PinkmanObject